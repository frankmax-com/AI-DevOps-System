# Azure DevOps CI/CD Pipeline for Dev Agent Service
# Handles build, test, security scanning, and deployment

trigger:
  branches:
    include:
    - main
    - develop
    - features/*
    - hotfix/*
  paths:
    include:
    - dev-agent-service/src/
    - dev-agent-service/tests/
    exclude:
    - dev-agent-service/README.md
    - dev-agent-service/docs/

pr:
  branches:
    include:
    - main
    - develop
  paths:
    include:
    - dev-agent-service/src/
    - dev-agent-service/tests/

variables:
  # Agent image with Python support
  imageName: 'ubuntu-latest'

  # Service configuration
  serviceName: 'dev-agent-service'
  containerRegistry: 'ai-devops-cr.azurecr.io'
  dockerFile: 'dev-agent-service/Dockerfile'
  dockerBuildContext: 'dev-agent-service/'

  # Python configuration
  pythonVersion: '3.9'

  # Test configuration
  testResultsDirectory: 'dev-agent-service/test-results/'

stages:
# ==========================================
# BUILD STAGE
# ==========================================

- stage: Build
  displayName: 'Build Stage'
  jobs:
  - job: BuildAndTest
    displayName: 'Build, Test & Security Scan'

    pool:
      vmImage: $(imageName)

    steps:

    # Checkout code with submodule support
    - checkout: self
      fetchDepth: 0
      persistCredentials: true

    # Setup Python environment
    - task: UsePythonVersion@0
      inputs:
        versionSpec: $(pythonVersion)
        addToPath: true

    # Create venv
    - script: python -m venv venv
      displayName: 'Create Python Virtual Environment'

    # Install dependencies
    - script: |
        source venv/bin/activate
        cd $(dockerBuildContext)
        pip install --upgrade pip
        pip install -r requirements.txt
        pip install -r requirements-dev.txt
      displayName: 'Install Dependencies'

    # Run code quality checks
    - script: |
        source venv/bin/activate
        cd $(dockerBuildContext)
        # Linting and code quality
        pip install flake8 black isort
        flake8 src/ --max-line-length=88 --extend-ignore=E203,W503
        black --check --diff src/
        isort --check-only --diff src/
      displayName: 'Code Quality Checks'

    # Run unit tests
    - script: |
        source venv/bin/activate
        cd $(dockerBuildContext)
        pip install pytest pytest-cov pytest-asyncio
        mkdir -p $(testResultsDirectory)

        # Run tests with coverage
        pytest tests/ \
          --junitxml=$(testResultsDirectory)junit.xml \
          --cov=src/ \
          --cov-report=xml \
          --cov-report=html \
          --cov-fail-under=85
      displayName: 'Run Unit Tests & Generate Coverage'

    # Publish test results
    - task: PublishTestResults@2
      inputs:
        testResultsFiles: '$(testResultsDirectory)*.xml'
        testRunTitle: 'Python Tests'
        failTaskOnFailedTests: true
      condition: succeededOrFailed()

    # Publish code coverage
    - task: PublishCodeCoverageResults@1
      inputs:
        codeCoverageTool: Cobertura
        summaryFileLocation: '$(testResultsDirectory)coverage.xml'
        reportDirectory: '$(testResultsDirectory)htmlcov/'
      condition: succeededOrFailed()

    # Run security scanning
    - task: SecurityScan@3
      inputs:
        tool: 'bandit'
        banditConfigFile: 'dev-agent-service/pyproject.toml'
        arguments: '--recursive dev-agent-service/src/'
      displayName: 'Python Security Scan (Bandit)'
      continueOnError: false

    # Run dependency vulnerability check
    - script: |
        source venv/bin/activate
        cd $(dockerBuildContext)
        pip install safety
        safety check  # Scans for known security vulnerabilities in dependencies
      displayName: 'Dependency Vulnerability Scan'
      continueOnError: false

    # Build Docker image
    - task: Docker@2
      inputs:
        command: 'buildAndPush'
        containerRegistry: 'Azure Container Registry'
        repository: $(serviceName)
        dockerfile: $(dockerFile)
        buildContext: $(dockerBuildContext)
        tags: |
          $(Build.BuildId)
          latest
      displayName: 'Build & Push Docker Image'

    # Run container smoke tests
    - script: |
        docker run --rm \
          -e AZURE_DEVOPS_PAT=$(AzureDevOpsPAT) \
          --entrypoint python \
          $(containerRegistry)/$(serviceName):$(Build.BuildId) \
          -c "from src.main import SERVICE_NAME, SERVICE_VERSION; print(f'{SERVICE_NAME} v{SERVICE_VERSION} container test passed')"
      displayName: 'Container Smoke Tests'

# ==========================================
# SECURITY SCANNING STAGE
# ==========================================

- stage: Security
  displayName: 'Security Validation'
  dependsOn: Build
  condition: succeeded()

  jobs:
  - job: SecurityValidation
    displayName: 'Deep Security Analysis'

    pool:
      vmImage: $(imageName)

    steps:
    # Container image vulnerability scan
    - task: Docker@2
      inputs:
        command: 'scan'
        containerRegistry: 'Azure Container Registry'
        repository: $(serviceName)
        imageId: $(containerRegistry)/$(serviceName):$(Build.BuildId)
        scanType: 'container'
      displayName: 'Container Image Security Scan'

    # Infrastructure as Code scanning
    - script: |
        # Placeholder for IaC security scanning
        echo "IaC scanning would go here (e.g., Checkov, Tfsec)"
      displayName: 'Infrastructure as Code Security'

# ==========================================
# DEPLOYMENT STAGE
# ==========================================

- stage: Deploy
  displayName: 'Deployment Stage'
  dependsOn: Security
  condition: |
    and(
      succeeded(),
      eq(dependencies.Security.result, 'Succeeded')
    )

  jobs:

  # Deploy to Development Environment
  - deployment: DeployToDev
    displayName: 'Deploy to Development'
    environment: 'dev'
    pool:
      name: 'Docker-Hospitalizingd Agents'

    strategy:
      runOnce:
        deploy:
          steps:
          # Deploy to dev environment using Helm/Kubernetes
          - script: |
              echo "Deploying to development environment..."
              # Placeholder - would use Helm/Kubernetes manifests
            displayName: 'Deploy to Kubernetes Dev'

          # Run post-deployment tests
          - script: |
              echo "Running post-deployment health checks..."
              # Test service health, endpoints, integrations
            displayName: 'Post-Deployment Tests'

  # Deploy to Staging Environment
  - deployment: DeployToStaging
    displayName: 'Deploy to Staging'
    dependsOn: DeployToDev
    environment: 'staging'
    pool:
      name: 'ADU-Agent-Pool'

    strategy:
      runOnce:
        deploy:
          steps:
          # Integration tests in staging
          - script: |
              echo "Running integration tests in staging..."
              # Full integration test suite against staging environment
            displayName: 'Integration Tests'

          # Performance testing
          - script: |
              echo "Running performance tests..."
              # Load testing, response time validation
            displayName: 'Performance Validation'

  # Production Deployment (Manual Approval)
  - deployment: DeployToProduction
    displayName: 'Deploy to Production'
    dependsOn: DeployToStaging
    environment: 'production'
    pool:
      name: 'ADU-Agent-Pool'

    strategy:
      runOnce:
        deploy:
          steps:
          - script: |
              echo "Production deployment approved and executed..."
              # Blue-green deployment, rollback preparation, monitoring setup
            displayName: 'Production Deployment'

# ==========================================
# MONITORING STAGE
# ==========================================

- stage: Monitor
  displayName: 'Post-Deployment Monitoring'
  dependsOn: Deploy
  condition: succeeded()

  jobs:
  - job: HealthMonitoring
    displayName: 'Service Health Validation'

    pool:
      vmImage: $(imageName)

    steps:
    # Validate production deployment
    - script: |
        # Health check validation
        curl -f https://production-url/health || exit 1
        echo "Service health validated"
      displayName: 'Production Health Checks'

    # Send deployment notification
    - script: |
        # Send alerts to monitoring systems
        echo "Deployment successful - notifications sent to stakeholders"
      displayName: 'Deployment Notifications'

# ==========================================
# RELEASE NOTES GENERATION
# ==========================================

- stage: Release
  displayName: 'Release Management'
  dependsOn: Monitor
  condition: succeeded()

  jobs:
  - job: GenerateRelease
    displayName: 'Create Release Notes'

    pool:
      vmImage: $(imageName)

    steps:
    # Generate CHANGELOG.md for release
    - script: |
        echo "Generating release notes..."
        # This could be automated by querying CHANGELOG.md
        # For now, manual release notes generation
      displayName: 'Generate Release Notes'

    # Update GitHub release
    - script: |
        echo "Creating GitHub release with CHANGELOG content..."
      displayName: 'Create GitHub Release'

    # Send dev team notification
    - script: |
        echo "New version deployed successfully!"
        # Send Slack/email notifications to development team
      displayName: 'Team Notifications'
